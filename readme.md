# 类的继承

## 继承的作用

继承可以描述类与类之间的关系

> 坦克 、 玩家坦克 、敌方坦克
> 玩家坦克是坦克，敌方坦克是坦克

如果A和B都是类，并且可以描述为A是B，则A和B形成继承关系
- B是父类，A是子类
- B派生A，A继承自B
- B是A的基类，A是B的派生类

如果A继承自B，则A自动拥有B的所有成员

## 成员的重写

重写：子类中覆盖父类的成员
> 注意：子类成员不能改变父类成员的类型
> 无论是属性还是方法，子类都可以对父类的相应成员进行重写，但是重写时，需要保证类型的匹配

> 注意this关键字： 在继承关系中，this的指向时动态的----调用方法时，根据具体的调用者确定this指向

> super关键字（表示父类的意思）：在子类方法中，可以使用super关键字读取父类成员

## 类型匹配

鸭子辨型法

子类的对象，始终可以赋值给父类

面向对象中，这种现象，叫做里氏替换原则

如果需要判断一个数据具体子类类型， 可以使用instanceof

## protected

readonly 只读修饰符
 访问权限修饰符： private（私有的） public（公开的） protected（受保护的)

 - protected :受保护的，只能在子类和自身中访问



 ## 继承的单根性和传递性

 单根性：每个类最多只能有一个父类 
 传递性：如果A是B的父类，B是C的父类，那么A也是C的父类

 # 抽象类
  - 有时，某个类只表示一个抽象概念，只要用于提取子类共有的成员，而不能直接创建他的对象，该类可以作为抽象类

  - 用法 给类前面加上``` abstract ```,表示该类是一个抽象类，不可以创建一个抽象类的对象 

  ## 抽象成员

  在父类中，可能知道**有些成员是必须存在的，但是不知道该成员的值或实现是什么**，因此，需要一种**强约束**，让继承该父类的子类，必须实现该成员

  ***在抽象类中***，可以有抽象成员，这些抽象成员必须在子类实现  

  ## 设计模式 --- 模版模式
  - 设计模式：面对一下常见的功能场景，有一些固定的，经过多年时间的成熟方法，这些方法称之为设计模式

  - 模版模式：有些方法，所有的子类实现的流程完全一致，只有流程中的某个步骤的具体实现不一致，那么这个时候，可以将该方法提取到父类，在父类中完成整个流程的实现， 遇到直线不一致的方法时，将该方法做成抽象方法

  # 静态成员
   - 静态成员是指，附着在类上的成员（属于某个构造函数的成员）
   - 使用static 修饰的成员，是静态成员
   - 实例成员，对象成员，属于某个类的对象
   - 静态成员，非实例成员，属于某个类
   ## 静态方法中的this
   在静态方法中，this指的是类
   在实例方法中this，指向的是当前实例对象

   ## 设计模式 --- 单例模式

   单例模式： 某些类的对象，在系统中最多只能有一个，为了避免开发者造成随意创建多个类对象的错误，可以使用单例模式进行强约束
   将构造函数 进行私有化 private